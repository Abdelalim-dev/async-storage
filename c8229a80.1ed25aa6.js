(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{153:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return s}));var a=t(2),r=t(9),l=(t(0),t(157)),c={id:"api",title:"API",sidebar_label:"API"},o={id:"api",title:"API",description:"\x3c!-- ------------------------ GET ITEM ------------------------ --\x3e",source:"@site/docs/API.md",permalink:"/async-storage/docs/api",editUrl:"https://github.com/react-native-community/async-storage/edit/master/website/docs/API.md",sidebar_label:"API",sidebar:"docs",previous:{title:"Manual linking",permalink:"/async-storage/docs/link"},next:{title:"Jest integration",permalink:"/async-storage/docs/advanced/jest"}},b=[{value:"<code>getItem</code>",id:"getitem",children:[]},{value:"<code>setItem</code>",id:"setitem",children:[]},{value:"<code>mergeItem</code>",id:"mergeitem",children:[]},{value:"<code>removeItem</code>",id:"removeitem",children:[]},{value:"<code>getAllKeys</code>",id:"getallkeys",children:[]},{value:"<code>multiGet</code>",id:"multiget",children:[]},{value:"<code>multiSet</code>",id:"multiset",children:[]},{value:"<code>multiMerge</code>",id:"multimerge",children:[]},{value:"<code>multiRemove</code>",id:"multiremove",children:[]},{value:"<code>clear</code>",id:"clear",children:[]},{value:"<code>useAsyncStorage</code>",id:"useasyncstorage",children:[]}],i={rightToc:b};function s(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},i,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"getitem"},Object(l.b)("inlineCode",{parentName:"h2"},"getItem")),Object(l.b)("p",null,"Gets a string value for given ",Object(l.b)("inlineCode",{parentName:"p"},"key"),". This function can either return a string value for existing ",Object(l.b)("inlineCode",{parentName:"p"},"key")," or return ",Object(l.b)("inlineCode",{parentName:"p"},"null")," otherwise."),Object(l.b)("p",null,"In order to store object value, you need to deserialize it, e.g. using ",Object(l.b)("inlineCode",{parentName:"p"},"JSON.parse()"),"."),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"Note (legacy)"),": you can use optional callback as an alternative for returned promise."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static getItem(key: string, [callback]: ?(error: ?Error, result: ?string) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," resolving with a string value, if entry exists for given ",Object(l.b)("inlineCode",{parentName:"p"},"key"),", or ",Object(l.b)("inlineCode",{parentName:"p"},"null")," otherwise."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," can also be rejected in case of underlying storage error."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\ngetMyStringValue = async () => {\n  try {\n    return await AsyncStorage.getItem('@key')\n  } catch(e) {\n    // read error\n  }\n\n  console.log('Done.')\n\n}\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\ngetMyObject = async () => {\n  try {\n    const jsonValue = await AsyncStorage.getItem('@key')\n    return jsonValue != null ? JSON.parse(jsonValue) : null\n  } catch(e) {\n    // read error\n  }\n\n  console.log('Done.')\n\n}\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"setitem"},Object(l.b)("inlineCode",{parentName:"h2"},"setItem")),Object(l.b)("p",null,"Sets a string ",Object(l.b)("inlineCode",{parentName:"p"},"value")," for given ",Object(l.b)("inlineCode",{parentName:"p"},"key"),". This operation can either modify an existing entry, if it did exist for given ",Object(l.b)("inlineCode",{parentName:"p"},"key"),", or add new one otherwise. "),Object(l.b)("p",null,"In order to store object value, you need to serialize it, e.g. using ",Object(l.b)("inlineCode",{parentName:"p"},"JSON.stringify()"),"."),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"Note (legacy)"),": you can use optional callback as an alternative for returned promise."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static setItem(key: string, value: string, [callback]: ?(error: ?Error) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," resolving when the set operation is completed."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," can also be rejected in case of underlying storage error."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\nsetStringValue = async (value) => {\n  try {\n    await AsyncStorage.setItem('key', value)\n  } catch(e) {\n    // save error\n  }\n\n  console.log('Done.')\n}\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\nsetObjectValue = async (value) => {\n  try {\n    const jsonValue = JSON.stringify(value)\n    await AsyncStorage.setItem('key', jsonValue)\n  } catch(e) {\n    // save error\n  }\n\n  console.log('Done.')\n}\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"mergeitem"},Object(l.b)("inlineCode",{parentName:"h2"},"mergeItem")),Object(l.b)("p",null,"Merges an existing value stored under ",Object(l.b)("inlineCode",{parentName:"p"},"key"),", with new ",Object(l.b)("inlineCode",{parentName:"p"},"value"),", assuming both values are ",Object(l.b)("strong",{parentName:"p"},"stringified JSON"),".\n",Object(l.b)("strong",{parentName:"p"},"NOTE"),": This is not supported by all native implementations."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static mergeItem(key: string, value: string, [callback]: ?(error: ?Error) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," with merged data, if exists, ",Object(l.b)("inlineCode",{parentName:"p"},"null")," otherwise."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const USER_1 = {\n  name: 'Tom',\n  age: 20,\n  traits: {\n    hair: 'black',\n    eyes: 'blue'\n  }\n}\n\nconst USER_2 = {\n  name: 'Sarah',\n  age: 21,\n  hobby: 'cars',\n  traits: {\n    eyes: 'green',\n  }\n}\n\n\nmergeUsers = async () => {\n  try {\n    //save first user\n    await AsyncStorage.setItem('@MyApp_user', JSON.stringify(USER_1))\n\n    // merge USER_2 into saved USER_1\n    await AsyncStorage.mergeItem('@MyApp_user', JSON.stringify(USER_2))\n\n    // read merged item\n    const currentUser = await AsyncStorage.getItem('@MyApp_user')\n\n    console.log(currentUser)\n\n    // console.log result:\n    // {\n    //   name: 'Sarah',\n    //   age: 21,\n    //   traits: {\n    //     eyes: 'green',\n    //     hair: 'black'\n    //   }\n    // }\n  }\n}\n\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"removeitem"},Object(l.b)("inlineCode",{parentName:"h2"},"removeItem")),Object(l.b)("p",null,"Removes item for a ",Object(l.b)("inlineCode",{parentName:"p"},"key"),", invokes (optional) callback once completed."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static removeItem(key: string, [callback]: ?(error: ?Error) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"removeValue = async () => {\n  try {\n    await AsyncStorage.removeItem('@MyApp_key')\n  } catch(e) {\n    // remove error\n  }\n\n  console.log('Done.')\n}\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"getallkeys"},Object(l.b)("inlineCode",{parentName:"h2"},"getAllKeys")),Object(l.b)("p",null,"Returns all keys known to your App, for all callers, libraries, etc. Once completed, invokes ",Object(l.b)("inlineCode",{parentName:"p"},"callback")," with errors (if any) and array of keys."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static getAllKeys([callback]: ?(error: ?Error, keys: ?Array<string>) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\ngetAllKeys = async () => {\n  let keys = []\n  try {\n    keys = await AsyncStorage.getAllKeys()\n  } catch(e) {\n    // read key error\n  }\n\n  console.log(keys)\n  // example console.log result:\n  // ['@MyApp_user', '@MyApp_key']\n}\n\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiget"},Object(l.b)("inlineCode",{parentName:"h2"},"multiGet")),Object(l.b)("p",null,"Fetches multiple key-value pairs for given array of ",Object(l.b)("inlineCode",{parentName:"p"},"keys")," in a batch. Once completed, invokes ",Object(l.b)("inlineCode",{parentName:"p"},"callback")," with errors (if any) and results."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static multiGet(keys: Array<string>, [callback]: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," of array with coresponding key-value pairs found, stored as ",Object(l.b)("inlineCode",{parentName:"p"},"[key, value]")," array."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"\ngetMultiple = async () => {\n\n  let values\n  try {\n    values = await AsyncStorage.multiGet(['@MyApp_user', '@MyApp_key'])\n  } catch(e) {\n    // read error\n  }\n  console.log(values)\n\n  // example console.log output:\n  // [ ['@MyApp_user', 'myUserValue'], ['@MyApp_key', 'myKeyValue'] ]\n}\n\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiset"},Object(l.b)("inlineCode",{parentName:"h2"},"multiSet")),Object(l.b)("p",null,"Stores multiple key-value pairs in a batch. Once completed, ",Object(l.b)("inlineCode",{parentName:"p"},"callback")," with any errors will be called."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static multiSet(keyValuePairs: Array<Array<string>>, [callback]: ?(errors: ?Array<Error>) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'\nmultiSet = async () => {\n  const firstPair = ["@MyApp_user", "value_1"]\n  const secondPair = ["@MyApp_key", "value_2"]\n  try {\n    await AsyncStorage.multiSet([firstPair, secondPair])\n  } catch(e) {\n    //save error\n  }\n\n  console.log("Done.")\n}\n\n')),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"multimerge"},Object(l.b)("inlineCode",{parentName:"h2"},"multiMerge")),Object(l.b)("p",null,"Multiple merging of existing and new values in a batch. Assumes that values are ",Object(l.b)("em",{parentName:"p"},"stringified JSON"),". Once completed, invokes ",Object(l.b)("inlineCode",{parentName:"p"},"callback")," with errors (if any).\n",Object(l.b)("strong",{parentName:"p"},"NOTE"),": This is not supported by all native implementations."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static multiMerge(keyValuePairs: Array<Array<string>>, [callback]: ?(errors: ?Array<Error>) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const USER_1 = {\n  name: 'Tom',\n  age: 30,\n  traits: {hair: 'brown'},\n};\n\nconst USER_1_DELTA = {\n  age: 31,\n  traits: {eyes: 'blue'},\n};\n\nconst USER_2 = {\n  name: 'Sarah',\n  age: 25,\n  traits: {hair: 'black'},\n};\n\nconst USER_2_DELTA = {\n  age: 26,\n  traits: {hair: 'green'},\n};\n\n\nconst multiSet = [\n  [\"@MyApp_USER_1\", JSON.stringify(USER_1)],\n  [\"@MyApp_USER_2\", JSON.stringify(USER_2)]\n]\n\nconst multiMerge = [\n  [\"@MyApp_USER_1\", JSON.stringify(USER_1_DELTA)],\n  [\"@MyApp_USER_2\", JSON.stringify(USER_2_DELTA)]\n]\n\n\nmergeMultiple = async () => {\n  let currentlyMerged\n\n  try {\n    await AsyncStorage.multiSet(multiSet)\n    await AsyncStorage.multiMerge(multiMerge)\n    currentlyMerged = await AsyncStorage.multiGet(['@MyApp_USER_1', '@MyApp_USER_2'])\n  } catch(e) {\n    // error\n  }\n\n  console.log(currentlyMerged)\n  // console.log output:\n  // [\n  //   [\n  //     'USER_1',\n  //     {\n  //       name:\"Tom\",\n  //       age:30,\n  //       traits: {\n  //         hair: 'brown'\n  //         eyes: 'blue'\n  //       }\n  //     }\n  //   ],\n  //   [\n  //     'USER_2',\n  //     {\n  //       name:'Sarah',\n  //       age:26,\n  //       traits: {\n  //         hair: 'green'\n  //       }\n  //     }\n  //   ]\n  // ]\n}\n\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiremove"},Object(l.b)("inlineCode",{parentName:"h2"},"multiRemove")),Object(l.b)("p",null,"Clears multiple key-value entries for given array of ",Object(l.b)("inlineCode",{parentName:"p"},"keys")," in a batch. Once completed, invokes a ",Object(l.b)("inlineCode",{parentName:"p"},"callback")," with errors (if any)."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static multiRemove(keys: Array<string>, [callback]: ?(errors: ?Array<Error>) => void)\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"removeFew = async () => {\n  const keys = ['@MyApp_USER_1', '@MyApp_USER_2']\n  try {\n    await AsyncStorage.multiRemove(keys)\n  } catch(e) {\n    // remove error\n  }\n\n  console.log('Done')\n}\n\n")),Object(l.b)("br",null),Object(l.b)("br",null),Object(l.b)("h2",{id:"clear"},Object(l.b)("inlineCode",{parentName:"h2"},"clear")),Object(l.b)("p",null,"Removes ",Object(l.b)("strong",{parentName:"p"},"whole")," ",Object(l.b)("inlineCode",{parentName:"p"},"AsyncStorage")," data, for all clients, libraries, etc. You probably want to use ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"#removeItem"}),"removeItem")," or ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"#multiRemove"}),"multiRemove")," to clear only your App's keys."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static clear([callback]: ?(error: ?Error) => void): Promise\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Promise")," object."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"clearAll = async () => {\n  try {\n    await AsyncStorage.clear()\n  } catch(e) {\n    // clear error\n  }\n\n  console.log('Done.')\n}\n\n")),Object(l.b)("h2",{id:"useasyncstorage"},Object(l.b)("inlineCode",{parentName:"h2"},"useAsyncStorage")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note"),": A hooks-like interface that we're experimenting with. This will change in the nearest future to fully leverage Hooks API, so feel free to ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/react-native-community/react-native-async-storage/issues/32"}),"follow this discussion to learn more"),"."),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"useAsyncStorage")," returns an object that exposes all methods that allow you to interact with the stored value."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"static useAsyncStorage(key: string): {\n  getItem: (\n    callback?: ?(error: ?Error, result: string | null) => void,\n  ) => Promise<string | null>,\n  setItem: (\n    value: string,\n    callback?: ?(error: ?Error) => void,\n  ) => Promise<null>,\n  mergeItem: (\n    value: string,\n    callback?: ?(error: ?Error) => void,\n  ) => Promise<null>,\n  removeItem: (callback?: ?(error: ?Error) => void) => Promise<null>,\n}\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"object")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Specific Example"),":"),Object(l.b)("p",null,"You can replace your ",Object(l.b)("inlineCode",{parentName:"p"},"App.js")," with the following to see it in action."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { useAsyncStorage } from '@react-native-community/async-storage';\n\nexport default function App() {\n  const [value, setValue] = useState('value');\n  const { getItem, setItem } = useAsyncStorage('@storage_key');\n\n  const readItemFromStorage = async () => {\n    const item = await getItem();\n    setValue(item);\n  };\n\n  const writeItemToStorage = async newValue => {\n    await setItem(newValue);\n    setValue(newValue);\n  };\n\n  useEffect(() => {\n    readItemFromStorage();\n  }, []);\n\n  return (\n    <View style={{ margin: 40 }}>\n      <Text>Current value: {value}</Text>\n      <TouchableOpacity\n        onPress={() =>\n          writeItemToStorage(\n            Math.random()\n              .toString(36)\n              .substr(2, 5)\n          )\n        }\n      >\n        <Text>Update value</Text>\n      </TouchableOpacity>\n    </View>\n  );\n}\n")),Object(l.b)("p",null,"In this example:"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"On mount, we read the value at ",Object(l.b)("inlineCode",{parentName:"li"},"@storage_key")," and save it to the state under ",Object(l.b)("inlineCode",{parentName:"li"},"value")),Object(l.b)("li",{parentName:"ol"},'When pressing on "update value", a new string gets generated, saved to async storage, and to the component state'),Object(l.b)("li",{parentName:"ol"},"Try to reload your app - you'll see that the last value is still being read from async storage")))}s.isMDXComponent=!0},157:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return j}));var a=t(0),r=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function b(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=r.a.createContext({}),s=function(e){var n=r.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},p=function(e){var n=s(e.components);return r.a.createElement(i.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,i=b(e,["components","mdxType","originalType","parentName"]),p=s(t),m=a,j=p["".concat(c,".").concat(m)]||p[m]||u[m]||l;return t?r.a.createElement(j,o({ref:n},i,{components:t})):r.a.createElement(j,o({ref:n},i))}));function j(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,c=new Array(l);c[0]=m;var o={};for(var b in n)hasOwnProperty.call(n,b)&&(o[b]=n[b]);o.originalType=e,o.mdxType="string"==typeof e?e:a,c[1]=o;for(var i=2;i<l;i++)c[i]=t[i];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);